/**
 * Copyright (C) 2014 Typesafe Inc. <http://www.typesafe.com>
 */
package akka.typed

import language.{ higherKinds, implicitConversions }
import scala.concurrent.duration.Duration
import scala.collection.immutable

/**
 * This object contains tools for building purely functional Actor
 * behaviors.
 */
object Pure {
  import akka.typed.{ ActorContext ⇒ AC }

  /**
   * Importing the contents of this object will adjust the compilation
   * environment such that all actor actions are described purely in terms of
   * [[Monadic]] values. In particular it will shadow the implicit conversion
   * which otherwise enables the use of the `!` operator on [[ActorRef]].
   */
  object semantics {
    implicit def shadowScalaActorRef1[T](ref: ActorRef[T]): ScalaActorRef[T] = ???
    implicit def shadowScalaActorRef2[T](ref: ActorRef[T]): ScalaActorRef[T] = ???
  }

  /**
   * The monad used for tracking effects that are generated by a [[PureContext]].
   */
  trait Monadic[T, U] {
    /**
     * Transform the current value using the given function that returns another
     * Monadic instance. The effects contained within that other instance are
     * appended to the effects accumulated within this instance (depending on the
     * [[ExecutionMode]]).
     */
    def flatMap[V](f: U ⇒ Monadic[T, V]): Monadic[T, V]
    /**
     * Transform the current value without generating additional effects.
     */
    def map[V](f: U ⇒ V): Monadic[T, V]
    /**
     * Execute the bound computation including all its effects according to the
     * given [[ExecutionMode]] and within the given (impure) [[ActorContext]].
     */
    def run(ctx: AC[T], mode: ExecutionMode): mode.Result[U]
  }

  /**
   * Marker trait which distinguishes [[Monadic]] instances that do not contain
   * effects.
   */
  trait MonadicWithoutEffects[T, U] extends Monadic[T, U]

  /**
   * Exploring going fully monadic on the effects; some of these (like self/props/system)
   * might be better modeled directly, not sure yet.
   */
  trait PureContext[T] extends Any {
    /**
     * Return the self-reference of this actor.
     */
    def self: MonadicWithoutEffects[T, ActorRef[T]]
    /**
     * Return the Props of this actor.
     */
    def props: MonadicWithoutEffects[T, Props[T]]
    /**
     * Return the ActorSystem to which this actor belongs.
     */
    def system: MonadicWithoutEffects[T, ActorSystem[Nothing]]
    /**
     * Return the list of child actors that this actor has spawned.
     */
    def children: MonadicWithoutEffects[T, Iterable[ActorRef[Nothing]]]
    /**
     * Query this actor’s list of child actors to possibly find one with the
     * given name.
     */
    def child(name: String): MonadicWithoutEffects[T, Option[ActorRef[Nothing]]]
    /**
     * Spawn a new child actor which starts out in the behavior given by the [[Props]]
     * and is deployed according to the contained deployment configuration.
     */
    def spawn[U](props: Props[U]): Monadic[T, ActorRef[U]]
    /**
     * Spawn a new child actor with a specific name which starts out in the
     * behavior given by the [[Props]] and is deployed according to the
     * contained deployment configuration. If a child actor with the given name
     * exists already then it is returned in the [[scala.Left]] projection of
     * the returned [[scala.Either]], otherwise the new actor’s reference is
     * given in the [[scala.Right]] projection.
     */
    def spawn[U](props: Props[U], name: String): Monadic[T, Either[ActorRef[Nothing], ActorRef[U]]]
    /**
     * Forcefully terminate the child actor with the given name if that exists.
     * The name is not an ActorPath, it can only contain a single name segment:
     * it is not possible to terminate actors that are not direct children of
     * this actor.
     *
     * IMPORTANT NOTE: the child actor will finish processing its current message
     * before it terminates, this method cannot be used to kill an actor that is
     * indefinitely blocked or waiting. There is no way to do that on the JVM.
     */
    def stop(childName: String): Monadic[T, Unit]
    /**
     * Register for deathwatch notifications pertaining to the given other actor.
     * As a result, this actor will receive a [[Terminated]] signal if the other
     * actor terminates or is declared terminated following a network partition.
     */
    def watch[U](other: ActorRef[U]): Monadic[T, ActorRef[U]]
    /**
     * Unregister from deatchwatch notifications pertaining to the given other
     * actor. After doing this a [[Terminated]] signal will not be received even
     * if the other actor terminates concurrently with the processing of this
     * effect.
     */
    def unwatch[U](other: ActorRef[U]): Monadic[T, ActorRef[U]]
    /**
     * Register for the delivery of a [[ReceiveTimeout]] signal in case no other
     * message is received for a duration greater than the given one. Set to
     * [[scala.concurrent.duration.Duration.Undefined]] in order to unregister, but beware that the signal
     * may be received afterwards if the timer fired concurrently with the
     * processing of this effect.
     */
    def setReceiveTimeout(d: Duration): Monadic[T, Unit]
    /**
     * Track a message send as an effect. This is optional in the sense that
     * sending directly through [[ActorRef]] is always possible (the `!` operator
     * can be disabled by importing the contents of [[semantics]] but the
     * `tell` method cannot be disabled).
     */
    def send[U](other: ActorRef[U], msg: U): Monadic[T, Unit]

    /**
     * Bind a pure computation without effects in a Monadic instance.
     */
    def bind[U](v: AC[T] ⇒ U): MonadicWithoutEffects[T, U]
    /**
     * Bind a pure computation with effects in a Monadic instance.
     */
    def bind[U](effect: Effect, v: AC[T] ⇒ U): Monadic[T, U]
    /**
     * Bind a simple value in a Monadic instance.
     */
    def unit[U](v: U): MonadicWithoutEffects[T, U]
  }

  /**
   * All tracked effects must extend implement this type. It is deliberately
   * not sealed in order to allow extensions.
   */
  trait Effect
  /**
   * A child actor was spawned with the given name. The child actor’s reference
   * can be obtained from the [[ActorContext]].
   */
  case class Spawned(childName: String) extends Effect
  /**
   * A termination request was sent for the named child.
   */
  case class Stopped(childName: String) extends Effect
  case class Watched[T](other: ActorRef[T]) extends Effect
  case class Unwatched[T](other: ActorRef[T]) extends Effect
  case class ReceiveTimeoutSet(d: Duration) extends Effect
  case class Messaged[U](other: ActorRef[U], msg: U) extends Effect
  case object EmptyEffect extends Effect

  case class Total[T](f: (PureContext[T], Either[Signal, T]) ⇒ Monadic[T, akka.typed.Behavior[T]]) extends akka.typed.Behavior[T] {
    def management(ctx: AC[T], msg: Signal): Behavior[T] = {
      val mode = ExecutionMode.NonTracking
      execute(ctx, f(mode.ctx, Left(msg)), mode)
    }
    def message(ctx: AC[T], msg: T): Behavior[T] = {
      val mode = ExecutionMode.NonTracking
      execute(ctx, f(mode.ctx, Right(msg)), mode)
    }

    def run(ctx: AC[T], msg: Either[Signal, T], mode: ExecutionMode): mode.Result[Behavior[T]] = execute(ctx, f(mode.ctx, msg), mode)
    def run(ctx: AC[T], msg: Either[Signal, T]): EffectsAndValue[Behavior[T]] = run(ctx, msg, ExecutionMode.Tracking)

    private def execute(ctx: AC[T], m: Monadic[T, Behavior[T]], mode: ExecutionMode): mode.Result[Behavior[T]] =
      mode.unwrapBehavior(m.run(ctx, mode), this)
  }

  /**
   * The execution mode determines how a [[Monadic]] computation is executed.
   * The only predefined differences concern the tracking of effects:
   *
   *  * [[ExecutionMode.NonTracking]] will not allocate or store effects, saving
   *    runtime overhead; this mode is used when an ActorAdapter executes a
   *    pure behavior (i.e. when spawning a pure behavior).
   *  * [[ExecutionMode.Tracking]] will allocate and store effects, which is
   *    useful primarily within test procedures.
   */
  trait ExecutionMode {
    /**
     * Type constructor for the result type of the [[Monadic#run]] method when
     * using this execution mode. The type argument will be the result type of
     * the Monadic instance.
     */
    type Result[_]

    /**
     * Combine one effect and one value into a Result. If effects are tracked
     * then it should be noted that [[EmptyEffect]] is meant to signify the
     * absence of an effect, hence it should not be added to collections of
     * effects.
     */
    def wrapOne[T](e: Effect, v: T): Result[T]

    /**
     * Combine the results (including effects) of a Monadic with the results
     * (and effects) of the Monadic that the given function produces.
     */
    def combine[C, T, U](ctx: AC[C], first: Monadic[C, T], f: T ⇒ Monadic[C, U]): Result[U]

    /**
     * When a behavior returns Behavior.Same this should be replaced within
     * the Result such that further execution of this next behavior remains
     * possible (Behavior.Same is just a marker object that will throw exceptions
     * when invoked). Effects that were present in the input Result shall be
     * retained in the output Result.
     */
    def unwrapBehavior[T](r: Result[Behavior[T]], old: Behavior[T]): Result[Behavior[T]]

    /**
     * Return an instance of [[PureContext]] that is tuned to this execution
     * mode. If effects are not tracked then this should not even allocate
     * objects for them to save runtime overhead.
     */
    def ctx[T]: PureContext[T]
  }

  object ExecutionMode {
    /**
     * Execution mode for efficient runtime evaluation with reduced allocation
     * overhead. This will still need to allocate the list nodes which model
     * the chain of bound functions within the Monadic in addition to those
     * function objects themselves.
     */
    object NonTracking extends ExecutionMode {
      type Result[T] = T

      def wrapOne[T](e: Effect, v: T): T = v
      def combine[C, T, U](ctx: AC[C], first: Monadic[C, T], f: T ⇒ Monadic[C, U]): Result[U] =
        f(first.run(ctx, NonTracking)).run(ctx, NonTracking)
      def unwrapBehavior[T](r: Result[Behavior[T]], old: Behavior[T]): Result[Behavior[T]] =
        if (r == Behavior.sameBehavior) old else r

      private val _ctx = new NonTrackingContextImpl
      def ctx[T] = _ctx.asInstanceOf[PureContext[T]]
    }

    /**
     * Execution mode for testing behaviors in isolation. In addition to
     * staging the execution of all effects (as for [[NonTracking]]) this will
     * keep track of the kinds of effects as they are executed. Running a
     * Monadic in this mode will produce a list of [[Effect]]s in addition to
     * the final result value.
     */
    object Tracking extends ExecutionMode {
      type Result[T] = EffectsAndValue[T]

      def wrapOne[T](e: Effect, v: T): Result[T] =
        e match {
          case EmptyEffect ⇒ EffectsAndValue(Nil, v)
          case other       ⇒ EffectsAndValue(other :: Nil, v)
        }
      def combine[C, T, U](ctx: AC[C], first: Monadic[C, T], f: T ⇒ Monadic[C, U]): Result[U] =
        first.run(ctx, Tracking) match {
          case EffectsAndValue(effects1, value1) ⇒ f(value1).run(ctx, Tracking) match {
            case EffectsAndValue(effects2, value2) ⇒ EffectsAndValue(effects1 ++ effects2, value2)
          }
        }
      def unwrapBehavior[T](r: Result[Behavior[T]], old: Behavior[T]): Result[Behavior[T]] =
        r match {
          case EffectsAndValue(effects, behv) if behv == Behavior.sameBehavior ⇒ EffectsAndValue(effects, old)
          case other ⇒ other
        }

      private val _ctx = new TrackingContextImpl
      def ctx[T] = _ctx.asInstanceOf[PureContext[T]]
    }
  }

  case class EffectsAndValue[T](effects: immutable.Seq[Effect], value: T)

  implicit class WithEffects[T](val x: EffectsAndValue[Behavior[T]]) extends AnyVal {
    def requireEffects(l: immutable.Seq[Effect]): Behavior[T] = {
      assert(x.effects == l, s"expected $l but got ${x.effects}")
      x.value
    }
    def requireEffects(s: Set[Effect]): Behavior[T] = {
      assert(x.effects.toSet == s, s"expected $s but got ${x.effects}")
      x.value
    }
    def requireEffects(_d: PF.type)(pf: PartialFunction[immutable.Seq[Effect], Unit]): Behavior[T] = {
      pf.applyOrElse(x.effects, FALSE)
      x.value
    }
    def requireEffects(_d: F1.type)(f: immutable.Seq[Effect] ⇒ Unit): Behavior[T] = {
      f(x.effects)
      x.value
    }
  }

  case object PF
  case object F1
  private val FALSE: (immutable.Seq[Effect]) ⇒ Unit = x ⇒ throw new AssertionError(s"effects ${x} did not match predicate")

  private class TrackingContextImpl[T] extends PureContext[T] {
    def self = bind(_.self)
    def props = bind(_.props)
    def system = bind(_.system)
    def children = bind(_.children)
    def child(name: String) = bind(_.child(name))
    def spawn[U](props: Props[U]) = bind(identity).flatMap { ctx ⇒
      val ref = ctx.spawn(props)
      bind(Spawned(ref.ref.path.name), _ ⇒ ref)
    }
    def spawn[U](props: Props[U], name: String) = bind(Spawned(name),
      ctx ⇒ ctx.child(name) match {
        case None      ⇒ Right(ctx.spawn(props, name))
        case Some(ref) ⇒ Left(ref)
      })
    def stop(childName: String) = bind(Stopped(childName), _.stop(childName))
    def watch[U](other: ActorRef[U]) = bind(Watched(other), _.watch(other))
    def unwatch[U](other: ActorRef[U]) = bind(Unwatched(other), _.unwatch(other))
    def setReceiveTimeout(d: Duration) = bind(ReceiveTimeoutSet(d), _.setReceiveTimeout(d))
    def send[U](other: ActorRef[U], msg: U) = bind(Messaged(other, msg), _ ⇒ other ! msg)

    def unit[U](v: U): MonadicWithoutEffects[T, U] = new MonadicWithoutEffectsImpl(_ ⇒ v)
    def bind[U](v: AC[T] ⇒ U): MonadicWithoutEffects[T, U] = new MonadicWithoutEffectsImpl(v)
    def bind[U](effect: Effect, v: AC[T] ⇒ U): Monadic[T, U] = new MonadicImpl(effect, v)
  }

  private class NonTrackingContextImpl[T] extends PureContext[T] {
    def self = bind(_.self)
    def props = bind(_.props)
    def system = bind(_.system)
    def children = bind(_.children)
    def child(name: String) = bind(_.child(name))
    def spawn[U](props: Props[U]) = bind(identity).flatMap { ctx ⇒
      val ref = ctx.spawn(props)
      bind(_ ⇒ ref)
    }
    def spawn[U](props: Props[U], name: String) = bind(ctx ⇒
      ctx.child(name) match {
        case None      ⇒ Right(ctx.spawn(props, name))
        case Some(ref) ⇒ Left(ref)
      })
    def stop(childName: String) = bind(_.stop(childName))
    def watch[U](other: ActorRef[U]) = bind(_.watch(other))
    def unwatch[U](other: ActorRef[U]) = bind(_.unwatch(other))
    def setReceiveTimeout(d: Duration) = bind(_.setReceiveTimeout(d))
    def send[U](other: ActorRef[U], msg: U) = bind(_ ⇒ other ! msg)

    def unit[U](v: U): MonadicWithoutEffects[T, U] = new MonadicWithoutEffectsImpl(_ ⇒ v)
    def bind[U](v: AC[T] ⇒ U): MonadicWithoutEffects[T, U] = new MonadicWithoutEffectsImpl(v)
    def bind[U](effect: Effect, v: AC[T] ⇒ U): Monadic[T, U] = new MonadicImpl(effect, v)
  }

  private class MonadicWithoutEffectsImpl[C, T](value: AC[C] ⇒ T) extends MonadicWithoutEffects[C, T] { self ⇒
    def flatMap[U](f: T ⇒ Monadic[C, U]): Monadic[C, U] = new DeferredMonadicImpl(this, f)
    def map[U](f: T ⇒ U): MonadicWithoutEffects[C, U] = new MonadicWithoutEffectsImpl(value andThen f)
    def run(ctx: AC[C], mode: ExecutionMode): mode.Result[T] = mode.wrapOne(EmptyEffect, value(ctx))
  }

  private class MonadicImpl[C, T](effect: Effect, value: AC[C] ⇒ T) extends Monadic[C, T] { self ⇒
    def flatMap[U](f: T ⇒ Monadic[C, U]): Monadic[C, U] = new DeferredMonadicImpl(this, f)
    def map[U](f: T ⇒ U): Monadic[C, U] = new MonadicImpl(effect, value andThen f)
    def run(ctx: AC[C], mode: ExecutionMode): mode.Result[T] = mode.wrapOne(effect, value(ctx))
  }

  private class DeferredMonadicImpl[C, T, U](predecessor: Monadic[C, T], f: T ⇒ Monadic[C, U]) extends Monadic[C, U] { self ⇒
    def flatMap[V](ff: U ⇒ Monadic[C, V]): Monadic[C, V] = new DeferredMonadicImpl(this, ff)
    def map[V](ff: U ⇒ V): Monadic[C, V] = new DeferredMonadicImpl(this, (t: U) ⇒ new MonadicImpl(EmptyEffect, _ ⇒ ff(t)))
    def run(ctx: AC[C], mode: ExecutionMode): mode.Result[U] = mode.combine(ctx, predecessor, f)
  }

}
