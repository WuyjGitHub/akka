/**
 * Copyright (C) 2014 Typesafe Inc. <http://www.typesafe.com>
 */
package akka.typed

import scala.concurrent.duration.FiniteDuration
import scala.reflect.ClassTag
import akka.actor.OneForOneStrategy
import scala.annotation.tailrec
import scala.collection.immutable

/**
 * The behavior of an actor defines how it reacts to the messages that it
 * receives. The message may either be of the type that the Actor declares
 * and which is part of the [[ActorRef]] signature, or it may be a system
 * [[Signal]] that expresses a lifecycle event of either this actor or one of
 * its child actors.
 *
 * Behaviors can be formulated in a number of different ways, either by
 * creating a derived class or by employing factory methods like
 * [[Behavior.Simple]], [[Behavior.Static]], [[Behavior.Full]] etc.
 */
abstract class Behavior[T] {
  def management(ctx: ActorContext[T], msg: Signal): Behavior[T]
  def message(ctx: ActorContext[T], msg: T): Behavior[T]
}

/**
 * System signals are notifications that are generated by the system and
 * delivered to the Actor behavior in a reliable fashion (i.e. they are
 * guaranteed to arrive in contrast to the at-most-once semantics of normal
 * Actor messages).
 */
sealed trait Signal
/**
 * Lifecycle signal that is fired upon creation of the Actor. This will be the
 * first message that the actor processes.
 */
final case object PreStart extends Signal
/**
 * Lifecycle signal that is fired upon restart of the Actor before replacing
 * the behavior with the fresh one (i.e. this signal is received within the
 * behavior that failed).
 */
final case class PreRestart(failure: Throwable) extends Signal
/**
 * Lifecycle signal that is fired upon restart of the Actor after replacing
 * the behavior with the fresh one (i.e. this signal is received within the
 * fresh replacement behavior).
 */
final case class PostRestart(failure: Throwable) extends Signal
/**
 * Lifecycle signal that is fired after this actor and all its child actors
 * (transitively) have terminated. The [[Terminated]] signal is only sent to
 * registered watchers after this signal has been processed.
 */
final case object PostStop extends Signal
/**
 * Lifecycle signal that is fired when a direct child actor fails. The child
 * actor will be suspended until its fate has been decided. The decision is
 * communicated by returning the next behavior wrapped in one of [[Failure.Resume]],
 * [[Failure.Restart]], [[Failure.Stop]] or [[Failure.Escalate]]. If this is not
 * done then the default behavior is to escalate the failure, which amounts to
 * failing this actor with the same exception that the child actor failed with.
 */
final case class Failed(cause: Throwable, child: ActorRef[Nothing]) extends Signal
/**
 * The actor can register for a notification in case no message is received
 * within a given time window, and the signal that is raised in this case is
 * this one. See also [[ActorContext#setReceiveTimeout]].
 */
final case object ReceiveTimeout extends Signal
/**
 * Lifecycle signal that is fired when an Actor that was watched has terminated.
 * Watching is performed by invoking the [[ActorContext#watch]] method.
 */
final case class Terminated(ref: ActorRef[Nothing]) extends Signal

/**
 * The parent of an actor decides upon the fate of a failed child actor by
 * encapsulating its next behavior in one of the four wrappers defined within
 * this class.
 */
object Failed {
  /**
   * Common supertype for the failure responses.
   */
  sealed abstract class Wrapper[T] extends Behavior[T] {
    def behavior: Behavior[T]
    def precedence: Int
    def wrap(b: Behavior[T]): Wrapper[T]
  }

  sealed trait Decision

  private[typed] case class NoFailure[T]() extends Wrapper[T] {
    def management(ctx: ActorContext[T], msg: Signal): Behavior[T] = ???
    def message(ctx: ActorContext[T], msg: T): Behavior[T] = ???
    def behavior: Behavior[T] = ???
    def precedence = 0
    def wrap(b: Behavior[T]): Wrapper[T] = ???
  }
  /**
   * Resuming the child actor means that the result of processing the message
   * on which it failed is just ignored, the previous state will be used to
   * process the next message. The message that triggered the failure will not
   * be processed again.
   */
  case class Resume[T](behavior: Behavior[T]) extends Wrapper[T] {
    def management(ctx: ActorContext[T], msg: Signal): Behavior[T] = behavior.management(ctx, msg)
    def message(ctx: ActorContext[T], msg: T): Behavior[T] = behavior.message(ctx, msg)
    def precedence = 1
    def wrap(b: Behavior[T]): Wrapper[T] = Resume(b)
  }
  object Resume extends Decision

  /**
   * Restarting the child actor means resetting its behavior to the initial
   * one that was provided during its creation (i.e. the one which was passed
   * into the [[Props]] constructor). The previously failed behavior will
   * receive a [[PreRestart]] signal before this happens and the replacement
   * behavior will receive a [[PostRestart]] signal afterwards.
   */
  case class Restart[T](behavior: Behavior[T]) extends Wrapper[T] {
    def management(ctx: ActorContext[T], msg: Signal): Behavior[T] = behavior.management(ctx, msg)
    def message(ctx: ActorContext[T], msg: T): Behavior[T] = behavior.message(ctx, msg)
    def precedence = 2
    def wrap(b: Behavior[T]): Wrapper[T] = Restart(b)
  }
  object Restart extends Decision

  /**
   * Stopping the child actor will free its resources and eventually
   * (asynchronously) unregister its name from the parent. Completion of this
   * process can be observed by watching the child actor and reacting to its
   * [[Terminated]] signal.
   */
  case class Stop[T](behavior: Behavior[T]) extends Wrapper[T] {
    def management(ctx: ActorContext[T], msg: Signal): Behavior[T] = behavior.management(ctx, msg)
    def message(ctx: ActorContext[T], msg: T): Behavior[T] = behavior.message(ctx, msg)
    def precedence = 3
    def wrap(b: Behavior[T]): Wrapper[T] = Stop(b)
  }
  object Stop extends Decision

  /**
   * The default response to a failure in a child actor is to escalate the
   * failure, entailing that the parent actor fails as well. This is equivalent
   * to an exception unwinding the call stack, but it applies to the supervision
   * hierarchy instead.
   */
  case class Escalate[T](behavior: Behavior[T]) extends Wrapper[T] {
    def management(ctx: ActorContext[T], msg: Signal): Behavior[T] = behavior.management(ctx, msg)
    def message(ctx: ActorContext[T], msg: T): Behavior[T] = behavior.message(ctx, msg)
    def precedence = 4
    def wrap(b: Behavior[T]): Wrapper[T] = Escalate(b)
  }
  object Escalate extends Decision

  /**
   * Remove the failure response marker wrappers from a behavior to obtain the
   * contained real behavior.
   */
  @tailrec final def unwrap[T](b: Behavior[T]): Behavior[T] =
    if (b.isInstanceOf[Wrapper[_]]) unwrap(b.asInstanceOf[Wrapper[T]].behavior)
    else b
}

/**
 * Several commonly used ways to express behaviors are bundled within this
 * object.
 */
object Behavior {

  /**
   * This type of behavior allows to handle all incoming messages within
   * the same user-provided partial function, be that a user message or a system
   * signal. For messages that do not match the partial function the same
   * behavior is emitted without change. This does entail that unhandled
   * failures of child actors will lead to a failure in this actor.
   *
   * For the lifecycle notifications pertaining to the actor itself this
   * behavior includes a fallback mechanism: an unhandled [[PreRestart]] signal
   * will terminate all child actors (transitively) and then emit a [[PostStop]]
   * signal in addition, whereas an unhandled [[PostRestart]] signal will emit
   * an additional [[PreStart]] signal.
   */
  case class Full[T](behavior: PartialFunction[(ActorContext[T], Either[Signal, T]), Behavior[T]]) extends Behavior[T] {
    override def management(ctx: ActorContext[T], msg: Signal): Behavior[T] = {
      lazy val fallback: ((ActorContext[T], Either[Signal, T])) ⇒ Behavior[T] = _ ⇒
        msg match {
          case PreRestart(_) ⇒
            ctx.children foreach { child ⇒
              ctx.unwatch(child.ref)
              ctx.stop(child.path.name)
            }
            behavior.applyOrElse((ctx, Left(PostStop)), fallback)
          case PostRestart(_) ⇒ behavior.applyOrElse((ctx, Left(PreStart)), fallback)
          case _              ⇒ Same
        }
      behavior.applyOrElse((ctx, Left(msg)), fallback)
    }
    override def message(ctx: ActorContext[T], msg: T): Behavior[T] = {
      behavior.applyOrElse((ctx, Right(msg)), (_: (ActorContext[T], Either[Signal, T])) ⇒ Same)
    }
  }

  /**
   * This type of behavior expects a total function that describes the actor’s
   * reaction to all system signals or user messages, without providing a
   * fallback mechanism for either. If you use partial function literal syntax
   * to create the supplied function then any message not matching the list of
   * cases will fail this actor with a [[scala.MatchError]].
   */
  case class FullTotal[T](behavior: (ActorContext[T], Either[Signal, T]) ⇒ Behavior[T]) extends Behavior[T] {
    override def management(ctx: ActorContext[T], msg: Signal) = behavior(ctx, Left(msg))
    override def message(ctx: ActorContext[T], msg: T) = behavior(ctx, Right(msg))
  }

  /**
   * This type of behavior is created from a total function from the declared
   * message type to the next behavior, which means that all possible incoming
   * messages for the given type must be handled. All system signals are
   * ignored by this behavior, which implies that a failure of a child actor
   * will be escalated unconditionally.
   *
   * This behavior type is most useful for leaf actors that do not create child
   * actors themselves.
   */
  case class Simple[T](behavior: T ⇒ Behavior[T]) extends Behavior[T] {
    override def management(ctx: ActorContext[T], msg: Signal): Behavior[T] = msg match {
      case _ ⇒ Same
    }
    override def message(ctx: ActorContext[T], msg: T): Behavior[T] = behavior(msg)
  }

  /**
   * This type of behavior is a variant of [[Behavior.Simple]] that does not
   * allow the actor to change behavior. It is an efficient choice for stateless
   * actors, possibly entering such a behavior after finishing its
   * initialization (which may be modeled using any of the other behavior types).
   *
   * This behavior type is most useful for leaf actors that do not create child
   * actors themselves.
   */
  case class Static[T](behavior: T ⇒ Unit) extends Behavior[T] {
    override def management(ctx: ActorContext[T], msg: Signal): Behavior[T] = msg match {
      case _ ⇒ Same
    }
    override def message(ctx: ActorContext[T], msg: T): Behavior[T] = {
      behavior(msg)
      this
    }
  }

  /**
   * A variant of [[Behavior.Simple]] that allows access to the [[ActorContext]]
   * for scheduling a [[ReceiveTimeout]] or watching other actors. All system signals are
   * ignored by this behavior, which implies that a failure of a child actor
   * will be escalated unconditionally.
   *
   * This behavior type is most useful for leaf actors that do not create child
   * actors themselves.
   */
  case class Contextual[T](behavior: (ActorContext[T], T) ⇒ Behavior[T]) extends Behavior[T] {
    override def management(ctx: ActorContext[T], msg: Signal): Behavior[T] = msg match {
      case _ ⇒ Same
    }
    override def message(ctx: ActorContext[T], msg: T): Behavior[T] = behavior(ctx, msg)
  }

  /**
   * A variant of [[Behavior.Contextual]] that also allows handling of system
   * notifications. The difference to [[Behavior.Full]] is that it separates
   * the channels for signals and user messages into different fucntions,
   * enabling the latter to benefit from exhaustiveness checking since it employs
   * a total function.
   *
   * This behavior employs the same fallback mechanism for [[PreRestart]] and
   * [[PostRestart]] signals as [[Behavior.Full]].
   */
  case class Composite[T](mgmt: PartialFunction[(ActorContext[T], Signal), Behavior[T]], behavior: (ActorContext[T], T) ⇒ Behavior[T]) extends Behavior[T] {
    override def management(ctx: ActorContext[T], msg: Signal): Behavior[T] = {
      lazy val fallback: ((ActorContext[T], Signal)) ⇒ Behavior[T] = _ ⇒
        msg match {
          case PreRestart(_) ⇒
            ctx.children foreach { child ⇒
              ctx.unwatch(child.ref)
              ctx.stop(child.path.name)
            }
            mgmt.applyOrElse((ctx, PostStop), fallback)
          case PostRestart(_) ⇒ mgmt.applyOrElse((ctx, PreStart), fallback)
          case _              ⇒ Same
        }
      mgmt.applyOrElse((ctx, msg), fallback)
    }
    override def message(ctx: ActorContext[T], msg: T): Behavior[T] = behavior(ctx, msg)
  }

  case class And[T](left: Behavior[T], right: Behavior[T]) extends Behavior[T] {
    private def sameOrOther(found: Behavior[T], old: Behavior[T]) =
      if (found eq sameBehavior) old else found

    override def management(ctx: ActorContext[T], msg: Signal): Behavior[T] = {
      val nl = left.management(ctx, msg)
      val nr = right.management(ctx, msg)
      val leftFailure = nl match {
        case w: Failed.Wrapper[_] ⇒ Some(w)
        case _                    ⇒ None
      }
      val rightFailure = nr match {
        case w: Failed.Wrapper[_] ⇒ Some(w)
        case _                    ⇒ None
      }
      val nextLeft = sameOrOther(Failed.unwrap(nl), left)
      val nextRight = sameOrOther(Failed.unwrap(nr), right)
      val next: Behavior[T] =
        if ((nextLeft ne stoppedBehavior) && (nextRight ne stoppedBehavior)) And(nextLeft, nextRight)
        else if (nextLeft ne stoppedBehavior) nextLeft
        else if (nextRight ne stoppedBehavior) nextRight
        else Stopped
      if (leftFailure.isDefined || rightFailure.isDefined) {
        val leftWrapper = leftFailure.getOrElse(Failed.NoFailure())
        val rightWrapper = rightFailure.getOrElse(Failed.NoFailure())
        if (leftWrapper.precedence >= rightWrapper.precedence) leftWrapper.wrap(next) else rightWrapper.wrap(next)
      } else next
    }

    override def message(ctx: ActorContext[T], msg: T): Behavior[T] = {
      val nl = left.message(ctx, msg)
      val nr = right.message(ctx, msg)
      val nextLeft = sameOrOther(nl, left)
      val nextRight = sameOrOther(nr, right)
      if ((nextLeft ne stoppedBehavior) && (nextRight ne stoppedBehavior)) And(nextLeft, nextRight)
      else if (nextLeft ne stoppedBehavior) nextLeft
      else if (nextRight ne stoppedBehavior) nextRight
      else Stopped
    }
  }

  case class Selective[T](timeout: FiniteDuration, selector: PartialFunction[T, Behavior[T]], onTimeout: () ⇒ Behavior[T]) // TODO

  def SelfAware[T](behavior: ActorRef[T] ⇒ Behavior[T]): Behavior[T] =
    Full {
      case (ctx, Left(PreStart)) ⇒
        val behv = behavior(ctx.self)
        val next = behv.management(ctx, PreStart)
        if (next == sameBehavior) behv else next
    }

  def ContextAware[T](behavior: ActorContext[T] ⇒ Behavior[T]): Behavior[T] =
    Full {
      case (ctx, Left(PreStart)) ⇒
        val behv = behavior(ctx)
        behv.management(ctx, PreStart)
    }

  /**
   * Return this behavior from message processing in order to advise the
   * system to reuse the previous behavior. This is provided in order to
   * avoid the allocation overhead of recreating the current behavior where
   * that is not necessary.
   */
  def Same[T]: Behavior[T] = sameBehavior.asInstanceOf[Behavior[T]]
  /**
   * Return this behavior from message processing to signal that this actor
   * shall terminate voluntarily. If this actor has created child actors then
   * these will be stopped as part of the shutdown procedure.
   */
  def Stopped[T]: Behavior[T] = stoppedBehavior.asInstanceOf[Behavior[T]]

  def Stopped[T](cleanup: () ⇒ Unit): Behavior[T] = new stoppedBehavior(cleanup).asInstanceOf[Behavior[T]]

  /**
   * INTERNAL API.
   */
  private[akka] object sameBehavior extends Behavior[Nothing] {
    override def management(ctx: ActorContext[Nothing], msg: Signal): Behavior[Nothing] = ???
    override def message(ctx: ActorContext[Nothing], msg: Nothing): Behavior[Nothing] = ???
  }

  /**
   * INTERNAL API.
   */
  private[akka] class stoppedBehavior(cleanup: () ⇒ Unit) extends Behavior[Nothing] {
    override def management(ctx: ActorContext[Nothing], msg: Signal): Behavior[Nothing] = { cleanup(); this }
    override def message(ctx: ActorContext[Nothing], msg: Nothing): Behavior[Nothing] = ???
  }

  /**
   * INTERNAL API.
   */
  private[akka] object stoppedBehavior extends stoppedBehavior(() ⇒ ())

}

